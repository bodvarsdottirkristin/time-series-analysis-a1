---
title: "R Notebook"
output: html_notebook
---
```{r}
library(ggplot2)
```

```{r}
### Read training data
#! Perhaps you need to set the working directory!?
#setwd("/home/pbac/g/course02417/2025/assignment1")
D <- read.csv("DST_BIL54.csv")
str(D)

# See the help
?strftime
D$time <- as.POSIXct(paste0(D$time,"-01"), "%Y-%m-%d", tz="UTC")
D$time
class(D$time)

## Year to month for each of them
D$year <- 1900 + as.POSIXlt(D$time)$year + as.POSIXlt(D$time)$mon / 12

## Make the output variable a floating point (i.e.\ decimal number)
D$total <- as.numeric(D$total) / 1E6

## Divide intro train and test set
teststart <- as.POSIXct("2024-01-01", tz="UTC")
Dtrain <- D[D$time < teststart, ]
Dtest <- D[D$time >= teststart, ]
```

```{r}
Dtrain
```
## 1. Plot data

1.1
```{r}
dates <- as.Date(Dtrain$time)

# Create x 
Dtrain$x <- as.numeric(format(Dtrain$time, "%Y")) + 
            (as.numeric(format(Dtrain$time, "%m")) - 1) / 12
```

1.2
```{r}
# Plot training data vs x

variable_of_interest = Dtrain$total
plot(Dtrain$x, variable_of_interest, type = "l", xlab = "Time Variable X", 
     ylab = "Total", main = "Total vs Time Variable X")

```

```{r}
# Basic statistics
cat("Start value (2018-01):", Dtrain$total[1], "\n") 
cat("End value (2023-12):", tail(Dtrain$total, 1), "\n")
cat("Total growth:", tail(Dtrain$total, 1) - Dtrain$total[1], "\n")
cat("Monthly observations:", nrow(Dtrain), "\n")
cat("Average monthly growth:", mean(diff(Dtrain$total)), "\n")
cat("Annual growth rate:", mean(diff(Dtrain$total)) * 12, "\n")

# Linear trend fit (R² for predictability)
fit <- lm(total ~ x, data = Dtrain)
cat("Linear model R²:", round(summary(fit)$r.squared, 3), "\n")

# Print results
print(fit)
```

The training data plot shows a clear upward trend in total registered motor vehicles in Denmark from 2018 to approximately 2022 with slight downward hills in beginning of 2022 and also in the end of 2022 leading up to the start of 2023. 


## 2. Linear trend model

```{r}
head(Dtrain[, c("x", "total")], 3)
```

## 3. OLS - global linear trend model

# 3.1. Estimate the parameters θ1 and θ2 using the training set (call it the Ordinary Least Squares (OLS) estimates). Describe how you calculated the estimates.

```{r}
y <- Dtrain$total
X <- cbind(1, Dtrain$x)

thetahat <- solve(t(X) %*% X) %*% t(X) %*% y

thetahat

```

# 3.2

```{r}

# Step 1: Residuals
residuals <- y - X %*% thetahat

# Step 2: Estimate sigma^2 (residual variance)
n <- nrow(X)           # 72 observations
p <- ncol(X)           # 2 parameters
sigma2_hat <- sum(residuals^2) / (n - p)  # unbiased estimator

# Step 3: Variance-covariance matrix of thetahat
V_theta <- sigma2_hat * solve(t(X) %*% X)

# Step 4: Standard errors = sqrt(diag(V_theta))
se_theta1 <- sqrt(V_theta[1,1])  # σ̂_θ₁
se_theta2 <- sqrt(V_theta[2,2])  # σ̂_θ₂

se_theta1

se_theta2
```

```{r}
fitted_mean <- X %*% thetahat  # μ̂(x) for all training points

plot(Dtrain$x, Dtrain$total, 
     pch = 16, col = "steelblue", cex = 0.8,
     xlab = "Time Variable x (fractional years)",
     ylab = "Total Registered Vehicles",
     main = "Observations and Estimated Mean")

lines(Dtrain$x, fitted_mean, col = "red", lwd = 2)

# Legend
legend("topleft", 
       legend = c("Observations y", "Estimated Mean)"), 
       pch = c(16, NA), 
       lty = c(NA, 1), 
       col = c("steelblue", "red"), 
       lwd = c(NA, 2))

```

# 3.3 Make a forecast for the test set, hence the following 12 months - i.e., compute predicted values
with corresponding prediction intervals for 2024-Jan to 2024-Dec. Present these values in a table.

```{r}
# Test set: 2024-Jan to Dec

# Create x 
Dtest$x <- as.numeric(format(Dtest$time, "%Y")) + 
            (as.numeric(format(Dtest$time, "%m")) - 1) / 12

X_test <- cbind(1, Dtest$x)

# Predictions + 95% prediction intervals
yhat_test <- X_test %*% thetahat

se_pred_test <- sqrt(sigma2_hat + diag(X_test %*% V_theta %*% t(X_test)))
t_crit <- qt(0.975, df = nrow(X) - ncol(X))  # 95% critical t-value

pred_int <- cbind(
  lower = yhat_test - t_crit * se_pred_test,
  upper = yhat_test + t_crit * se_pred_test
)

# Forecast table using Dtest months
forecast_table <- data.frame(
  Month = format(Dtest$time, "%b %Y"),
  x = round(Dtest$x, 3),
  Actual = round(Dtest$total, 3),
  Forecast = round(yhat_test, 3),
  `Lower 95%` = round(pred_int[,1], 3),
  `Upper 95%` = round(pred_int[,2], 3)
)
print(forecast_table, row.names = FALSE)
```


# 3.4 Plot the fitted model together with the training data and the forecasted values (also plot the prediction intervals of the forecasted values).



```{r}

# Order test data
ord <- order(Dtest$x)

# Dataframe for plot
Dpred <- data.frame(
  x = Dtest$x[ord],
  yhat = yhat_test[ord],
  lower = pred_int[ord, 1],
  upper = pred_int[ord, 2]
)


x_seq <- seq(min(c(Dtrain$x, Dtest$x)), 2025, length.out = 200)
Dfitted <- data.frame(
  x = x_seq,
  y = coef(fit)[1] + coef(fit)[2] * x_seq
)

ggplot() +
  geom_point(data = Dtrain,
             aes(x = x, y = total, color = "Training data")) +
  geom_point(data = Dtest,
             aes(x = x, y = total, color = "Test data")) +
  geom_line(data = Dfitted,
            aes(x = x, y = y, color = "Fitted model"),
            linewidth = 1) +
  geom_line(data = Dpred,
            aes(x = x, y = yhat, color = "Forecast"),
            linewidth = 1) +
  geom_line(data = Dpred,
            aes(x = x, y = lower, color = "95% Prediction Interval"),
            linetype = "dashed") +
  geom_line(data = Dpred,
            aes(x = x, y = upper, color = "95% Prediction Interval"),
            linetype = "dashed") +
  
  coord_cartesian(
    xlim = c(min(c(Dtrain$x, Dtest$x)), 2025),
    ylim = c(min(c(Dtrain$total, Dtest$total)), 3.4)) +
  
  scale_color_manual(
    name = "",
    values = c("Training data" = "black",
               "Test data" = "darkgreen",
               "Fitted model" = "blue",
               "Forecast" = "red",
               "95% Prediction Interval" = "red")) +
  
  labs(title = "Fitted Model with Forecast and Prediction Intervals",
       x = "Year",
       y = "Total registered vehicles (millions)") +
  
  theme_minimal() +
  theme(
    legend.position = "inside",
    legend.position.inside = c(0.02, 0.98),
    legend.justification = c(0, 0.9))
```

```{r}

X_train <- cbind(1, Dtrain$x)

# Predictions + 95% prediction intervals for training data
yhat_train <- X_train %*% thetahat

se_pred_train <- sqrt(sigma2_hat + diag(X_train %*% V_theta %*% t(X_train)))
t_crit_train <- qt(0.975, df = nrow(X) - ncol(X))  # 95% critical t-value
pred_int_train <- cbind(
  lower = yhat_train - t_crit_train * se_pred_train,
  upper = yhat_train + t_crit_train * se_pred_train
)

```

```{r}
# Order test data
ord_train <- order(Dtrain$x)

# Dataframe for plot
Dpred <- data.frame(
  x = Dtrain$x[ord_train],
  yhat = yhat_train[ord_train],
  lower = pred_int_train[ord_train, 1],
  upper = pred_int_train[ord_train, 2]
)


x_seq <- seq(min(c(Dtrain$x, Dtest$x)), 2024, length.out = 200)
Dfitted <- data.frame(
  x = x_seq,
  y = coef(fit)[1] + coef(fit)[2] * x_seq
)

ggplot() +
  geom_point(data = Dtrain,
             aes(x = x, y = total, color = "Training data")) +
  #geom_point(data = Dtest,
   #          aes(x = x, y = total, color = "Test data")) +
  geom_line(data = Dfitted,
            aes(x = x, y = y, color = "Fitted model"),
            linewidth = 1) +
  #geom_line(data = Dpred,
    #        aes(x = x, y = yhat, color = "Forecast"),
    #        linewidth = 1) +
  geom_line(data = Dpred,
            aes(x = x, y = lower, color = "95% Prediction Interval"),
            linetype = "dashed") +
  geom_line(data = Dpred,
            aes(x = x, y = upper, color = "95% Prediction Interval"),
            linetype = "dashed") +
  
  #coord_cartesian(
   # xlim = c(min(c(Dtrain$x, Dtest$x)), 2025),
    #ylim = c(min(c(Dtrain$total, Dtest$total)), 3.4)) +
  
  scale_color_manual(
    name = "",
    values = c("Training data" = "black",
               "Fitted model" = "red",
               "95% Prediction Interval" = "red")) +
  
  labs(title = "Fitted Model with Forecast and Prediction Intervals",
       x = "Year",
       y = "Total registered vehicles (millions)") +
  
  theme_minimal() +
  theme(
    legend.position = "inside",
    legend.position.inside = c(0.02, 0.98),
    legend.justification = c(0, 0.9))
```

# 3.6 Investigate the residuals of the model

```{r}
residuals <- fitted_mean - Dtrain$total

plot(Dtrain$x, residuals,
     pch = 16,
     xlab = "Year",
     ylab = "Residuals",
     main = "Residuals Over Time")
abline(h = 0, col = "red", lwd = 2)
```


```{r}
qqnorm(residuals)
qqline(residuals, col = "red")
```


```{r}
hist(residuals,
     breaks = 15,
     main = "Histogram of Residuals",
     xlab = "Residuals")
```

# 3.1 
```{r}
lambda <- 0.9
lambdas <- lambda^((nrow(Dtrain)-1):0)

plot_data <- data.frame(
  Time = Dtrain$year,
  Weight = lambdas
)


p <- ggplot(plot_data, aes(x = Time, y = Weight)) +
  geom_point() +                      
  labs(x = "Time", y = "Weight") +    
  theme_minimal()                     


print(p)

# 4. Save the plot
#ggsave("4_2.png", plot = p, width = 8, height = 6, dpi = 600)
```
# 4.3
```{r}
lambda_sum = sum(lambdas)
lambda_sum

OLS_sum = nrow(Dtrain)
OLS_sum
```
# 4.4
```{r}
cov = diag(1/lambdas)

X_train <- cbind(1, Dtrain$x)
Y_train <- Dtrain$total 

F_N = t(X_train) %*% solve(cov) %*% X_train
h_N = t(X_train) %*% solve(cov) %*% Y_train

theta_hat_wls <- solve(F_N) %*% h_N
theta_hat_wls
```
# 4.5
```{r}
library(ggplot2)

# ==========================================
# 1. OLS Full Model (Train + Test)
# ==========================================
# existing OLS thetahat and V_theta from sec 3
X_test  <- cbind(1, Dtest$x)
X_full  <- rbind(X_train, X_test)

# OLS Predictions for all data
y_hat_ols_full <- X_full %*% thetahat

# OLS standard errors and intervals for all data
se_pred_ols_full <- sqrt(sigma2_hat + diag(X_full %*% V_theta %*% t(X_full)))
t_crit_ols <- qt(0.975, df = nrow(X_train) - ncol(X_train))

pred_int_ols_full <- cbind(
  lower = y_hat_ols_full - t_crit_ols * se_pred_ols_full,
  upper = y_hat_ols_full + t_crit_ols * se_pred_ols_full
)

df_ols_full <- data.frame(
  x = c(Dtrain$x, Dtest$x),
  yhat = y_hat_ols_full,
  lower = pred_int_ols_full[, 1],
  upper = pred_int_ols_full[, 2],
  Model = "OLS (Global Trend)"
)

# ==========================================
# 2. WLS Full Model (Train + Test)
# ==========================================

# WLS variance and standard errors
res_wls <- Dtrain$total - (X_train %*% theta_hat_wls)
sigma2_wls <- sum(diag(solve(cov)) * res_wls^2) / (nrow(X_train) - ncol(X_train))
V_theta_wls <- sigma2_wls * solve(F_N)

# WLS Predictions
y_hat_wls_full <- X_full %*% theta_hat_wls

# WLS standard errors and intervals
se_pred_wls_full <- sqrt(sigma2_wls + diag(X_full %*% V_theta_wls %*% t(X_full)))
t_crit_wls <- qt(0.975, df = nrow(X_train) - ncol(X_train))

pred_int_wls_full <- cbind(
  lower = y_hat_wls_full - t_crit_wls * se_pred_wls_full,
  upper = y_hat_wls_full + t_crit_wls * se_pred_wls_full
)

df_wls_full <- data.frame(
  x = c(Dtrain$x, Dtest$x),
  yhat = y_hat_wls_full,
  lower = pred_int_wls_full[, 1],
  upper = pred_int_wls_full[, 2],
  Model = "WLS (Discounted, lambda=0.9)"
)

# Combine both models for easy plotting
df_models_full <- rbind(df_ols_full, df_wls_full)

# Combine actual data for plotting
df_actuals <- data.frame(
  x = c(Dtrain$x, Dtest$x),
  total = c(Dtrain$total, Dtest$total),
  Set = c(rep("Training Data", nrow(Dtrain)), rep("Test Data", nrow(Dtest)))
)

# ==========================================
# 3. Plotting the Full Models
# ==========================================
plot_4_5 <- ggplot() +
  # Actual observations
  geom_point(data = df_actuals, 
             aes(x = x, y = total, shape = Set), 
             color = "black", size = 1.5, alpha = 0.7) +
  
  # Lines for the fitted/forecasted models
  geom_line(data = df_models_full, 
            aes(x = x, y = yhat, color = Model), 
            linewidth = 1) +
  
  # Ribbons for the 95% prediction intervals
  geom_ribbon(data = df_models_full, 
              aes(x = x, ymin = lower, ymax = upper, fill = Model), 
              alpha = 0.15) +
  
  # Vertical line to show where training ends and test begins
  geom_vline(xintercept = min(Dtest$x), linetype = "dashed", color = "darkgray", linewidth = 0.8) +
  annotate("text", x = min(Dtest$x) + 0.05, y = mean(df_actuals$total), 
           label = "Forecast Start", angle = 90, vjust = -0.5, color = "darkgray") +
  
  # Formatting and aesthetics
  scale_shape_manual(name = "Data", values = c("Training Data" = 16, "Test Data" = 17)) +
  scale_color_manual(name = "Model", values = c("OLS (Global Trend)" = "blue", "WLS (Discounted, lambda=0.9)" = "red")) +
  scale_fill_manual(name = "Model", values = c("OLS (Global Trend)" = "blue", "WLS (Discounted, lambda=0.9)" = "red")) +
  
  labs(title = "Full Model Comparison: OLS vs. WLS (Training & Forecast)",
       x = "Year",
       y = "Total Registered Vehicles (Millions)") +
  
  theme_minimal() +
  theme(
    legend.position = "right",
    legend.box = "vertical"
  )

plot_4_5
#ggsave('4_5.png', plot =plot_4_5, height = 4, width = 8, dpi=400 )
```
# 4.6
```{r}
# ==========================================
# 4.6: WLS for various lambdas
# ==========================================
lambdas_to_test <- c(0.99, 0.9, 0.8, 0.7, 0.6)


results_list <- list()
slopes_list <- list() # To inspect the slopes later


for (l in lambdas_to_test) {
  # 1. Calculate weights and Weight matrix W (inverse of covariance)
  w <- l^((nrow(Dtrain)-1):0)
  W <- diag(w)
  
  # 2. Estimate parameters (theta_hat)
  F_N <- t(X_train) %*% W %*% X_train
  h_N <- t(X_train) %*% W %*% Y_train
  theta_hat <- solve(F_N) %*% h_N
  
  # Save the slope (theta_2) for our commentary
  slopes_list[[as.character(l)]] <- theta_hat[2, 1]
  
  # 3. Forecasts for all data points
  y_hat_full <- X_full %*% theta_hat
  
  # 4. Store in a temporary dataframe
  tmp_df <- data.frame(
    x = c(Dtrain$x, Dtest$x),
    yhat = as.numeric(y_hat_full),
    Lambda = as.factor(paste("lambda =", l))
  )
  results_list[[as.character(l)]] <- tmp_df
}

# Combine all results into one dataframe
df_lambdas <- do.call(rbind, results_list)

# Print the slopes to answer the question
cat("Estimated Slopes (theta_2) for different lambdas:\n")
print(unlist(slopes_list))

# ==========================================
# Plotting the different lambdas
# ==========================================
plot_4_6 <- ggplot() +
  # Actual observations
  geom_point(data = df_actuals, 
             aes(x = x, y = total, shape = Set), 
             color = "black", size = 1.5, alpha = 0.5) +
  
  # Fitted/Forecasted lines for each lambda
  geom_line(data = df_lambdas, 
            aes(x = x, y = yhat, color = Lambda), 
            linewidth = 1) +
  
  # Vertical line separating train/test
  geom_vline(xintercept = min(Dtest$x), linetype = "dashed", color = "darkgray", linewidth = 0.8) +
  annotate("text", x = min(Dtest$x) + 0.05, y = mean(df_actuals$total), 
           label = "Forecast Start", angle = 90, vjust = -0.5, color = "darkgray") +
  
  scale_shape_manual(name = "Data", values = c("Training Data" = 16, "Test Data" = 17)) +
  labs(title = "WLS Forecasts for Different Forgetting Factors (Lambda)",
       x = "Year",
       y = "Total Registered Vehicles (Millions)") +
  
  theme_minimal() +
  theme(legend.position = "right")

plot_4_6
#ggsave('4_6.png', plot = plot_4_6, height = 4, width = 8, dpi=400)
```


# 5.1

```{r}

y

X
#cat("y1 =", y[1], "\n")  # Jan 2018
# cat("y2 =", y[2], "\n")  # Feb 2018
# cat("x1 =", X[1,], "\n")      # ~2018.0  
# cat("x2 =", X[2,], "\n")      # ~2018.083

```

# 5.2

```{r}
# RLS
# Set the initial value of R and theta
p <- ncol(X) 
N <- nrow(X) # datapoints
R <- diag(0.1, nrow=p)
```

```{r}
theta <- c(0,0)#rep(0, p)
Theta <- matrix(NA, nrow=N, ncol=p)

# Iterate through and estimate the parameters
for(i in 1:N){
  (x <- X[i, ])
  # Update
  (R <- R + x %*% t(x))
  (theta <- theta + solve(R) %*% x %*% (y[i] - t(x) %*% theta))
  Theta[i, ] <- theta
}

Theta

Theta[1,] 
Theta[2,]
Theta[3,]

```

# 5.3. Calculate the RLS estimates at time t= N (i.e.
θN) and compare them to the OLS estimates,
are they close? Can you find a way to decrease the difference by modifying some of the RLS
initial values and explain why initial values are important to get right?

# From what I understand we should retrieve the last value of the Thetas
```{r}
theta <- c(0,0)#rep(0, p)
Theta <- matrix(NA, nrow=N, ncol=p)

# Iterate through and estimate the parameters
for(i in 1:N){
  (x <- X[i, ])
  # Update
  (R <- R + x %*% t(x))
  (theta <- theta + solve(R) %*% x %*% (y[i] - t(x) %*% theta))
  Theta[i, ] <- theta
}

Theta
```